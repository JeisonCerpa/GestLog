# Guía completa y sencilla para añadir un módulo a GestLog

Esta guía es una copia ampliada y completamente explicada, pensada para que cualquier miembro del equipo (incluso novatos) pueda crear un módulo nuevo en GestLog. Está escrita en lenguaje sencillo y contiene ejemplos listos para copiar, explicaciones de por qué se hace cada cosa, y pasos para integrar el módulo en la aplicación (DI, permisos, Herramientas, base de datos, tests y checklist final).

Índice
- Resumen rápido
- Estructura de carpetas recomendada
- Paso a paso (creación mínima)
- Qué poner en cada archivo: plantillas y explicación línea a línea
  - ViewModel
  - Model
  - Interface
  - Service (en memoria)
  - Service (con EF Core y Repository)
  - Repositorio (patrón simple)
  - DbContext y migraciones
  - View (XAML) y enlazado
- Registro en DI (qué editar y por qué)
- Integración con Herramientas (añadir la tarjeta / card)
- Permisos: cómo crearlos y comprobarlos
- Transacciones y manejo de errores (DB)
- Checklist final
- Siguientes pasos recomendados

---

Resumen rápido
1. Crea la carpeta `Modules/MiModulo` y subcarpetas `ViewModels`, `Views`, `Models`, `Interfaces`, `Services`, `Repositories`, `DocumentacionModulos`.
2. Implementa Model, Interface, Service (inicialmente en memoria) y ViewModel con comandos.
3. Crea la View (XAML) y enlázala al ViewModel.
4. Registra Service y ViewModel en DI (transient para ViewModels).
5. Añade permiso y la card en `Herramientas` para que el usuario pueda abrir el módulo.
6. Si necesitas persistencia, añade DbContext, repositorio y migraciones EF Core.

---

Estructura de carpetas recomendada
- Modules/MiModulo/
  - ViewModels/MiModuloViewModel.cs
  - Views/MiModuloView.xaml (+ .xaml.cs si hace falta)
  - Models/MiModuloModel.cs
  - Interfaces/IMiModuloService.cs
  - Services/MiModuloService.cs
  - Repositories/MiModuloRepository.cs
  - DocumentacionModulos/MiModulo-Usuario.md
  - README.md

Explicación: tener cada módulo autocontenido ayuda a mantener el código organizado y facilita pruebas y despliegues.

---

Paso a paso (creación mínima)
1) Crea carpetas. 2) Copia las plantillas que vienen abajo en los archivos. 3) Registra DI. 4) Añade permiso y card. 5) Ejecuta y prueba.

---

Qué poner en cada archivo: plantillas y explicación

1) ViewModels/MiModuloViewModel.cs
```csharp
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;

public partial class MiModuloViewModel : ObservableObject
{
    // Campo observable que la vista muestra
    [ObservableProperty]
    private string mensaje = "¡Bienvenido a Mi Módulo!";

    // Colección observable que se enlaza a un ListBox o DataGrid
    [ObservableProperty]
    private ObservableCollection<MiModuloModel> elementos = new();

    private readonly IMiModuloService _service;

    // El ViewModel pide el servicio por constructor (inyección de dependencias)
    public MiModuloViewModel(IMiModuloService service)
    {
        _service = service;
        // Cargamos datos al crear el ViewModel
        Cargar();
    }

    // Comando para cargar datos
    [RelayCommand]
    private void Cargar()
    {
        // Llamamos al servicio y llenamos la colección observable
        Elementos = new ObservableCollection<MiModuloModel>(_service.ObtenerElementos());
    }

    // Comando simple para ejemplo
    [RelayCommand]
    private void MostrarMensaje()
    {
        Mensaje = "Botón pulsado";
    }
}
```
Explicación línea a línea (simple):
- `[ObservableProperty]` genera la propiedad pública y notifica cambios (INotifyPropertyChanged). No tienes que escribir boilerplate.
- El ViewModel recibe `IMiModuloService` para separar la lógica de datos de la UI.
- `[RelayCommand]` crea comandos usables desde XAML: `CargarCommand`, `MostrarMensajeCommand`.


2) Models/MiModuloModel.cs
```csharp
public class MiModuloModel
{
    public int Id { get; set; }
    public string Nombre { get; set; }
    public string Descripcion { get; set; }
}
```
Explicación: POCO simple que representa filas de datos.


3) Interfaces/IMiModuloService.cs
```csharp
using System.Collections.Generic;

public interface IMiModuloService
{
    List<MiModuloModel> ObtenerElementos();
    MiModuloModel ObtenerPorId(int id);
    void Guardar(MiModuloModel item);
    void Eliminar(int id);
}
```
Explicación: define las operaciones que el ViewModel utilizará. Mantener la interfaz simple facilita tests.


4) Services/MiModuloService.cs (implementación en memoria para empezar)
```csharp
using System.Collections.Generic;
using System.Linq;

public class MiModuloService : IMiModuloService
{
    private readonly List<MiModuloModel> _datos = new()
    {
        new MiModuloModel { Id = 1, Nombre = "Ejemplo", Descripcion = "Primer elemento" }
    };

    public List<MiModuloModel> ObtenerElementos() => _datos.ToList();

    public MiModuloModel ObtenerPorId(int id) => _datos.FirstOrDefault(x => x.Id == id);

    public void Guardar(MiModuloModel item)
    {
        if (item.Id == 0)
        {
            item.Id = _datos.Any() ? _datos.Max(x => x.Id) + 1 : 1;
            _datos.Add(item);
        }
        else
        {
            var existente = ObtenerPorId(item.Id);
            if (existente != null)
            {
                existente.Nombre = item.Nombre;
                existente.Descripcion = item.Descripcion;
            }
        }
    }

    public void Eliminar(int id)
    {
        var item = ObtenerPorId(id);
        if (item != null) _datos.Remove(item);
    }
}
```
Explicación: útil para empezar sin base de datos; permite desarrollar UI y tests.


5) Repositorio simple (si vas a usar DB)
```csharp
public interface IMiModuloRepository
{
    Task<List<MiModuloEntity>> ObtenerAsync();
    Task<MiModuloEntity> ObtenerPorIdAsync(int id);
    Task GuardarAsync(MiModuloEntity entity);
    Task EliminarAsync(int id);
}

public class MiModuloRepository : IMiModuloRepository
{
    private readonly AppDbContext _db;
    public MiModuloRepository(AppDbContext db) { _db = db; }

    public async Task<List<MiModuloEntity>> ObtenerAsync() => await _db.MiModulo.ToListAsync();

    public async Task<MiModuloEntity> ObtenerPorIdAsync(int id) => await _db.MiModulo.FindAsync(id);

    public async Task GuardarAsync(MiModuloEntity entity)
    {
        if (entity.Id == 0) _db.MiModulo.Add(entity);
        else _db.MiModulo.Update(entity);
        await _db.SaveChangesAsync();
    }

    public async Task EliminarAsync(int id)
    {
        var e = await ObtenerPorIdAsync(id);
        if (e != null) { _db.MiModulo.Remove(e); await _db.SaveChangesAsync(); }
    }
}
```
Explicación: el repositorio encapsula llamadas a EF Core y permite cambiar la implementación sin tocar el servicio.


6) Entities y DbContext (EF Core)
- Entity class (opcionalmente distinta del Model usado en UI):
```csharp
public class MiModuloEntity
{
    public int Id { get; set; }
    public string Nombre { get; set; }
    public string Descripcion { get; set; }
}
```
- AppDbContext: (añádelo a la carpeta `Data` o `Infrastructure` si ya existe)
```csharp
using Microsoft.EntityFrameworkCore;

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

    public DbSet<MiModuloEntity> MiModulo { get; set; }

    // Si necesitas configurar nombres de tablas o relaciones, usa OnModelCreating
}
```
Explicación simple: DbContext representa la conexión a la base de datos y las tablas que usas.


7) Registrar DbContext y repositorios en DI (Startup o Program)
```csharp
// Ejemplo en Startup.Database.cs o Program.cs
services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(configuration.GetConnectionString("DefaultConnection")));

services.AddScoped<IMiModuloRepository, MiModuloRepository>();
services.AddScoped<IMiModuloService, MiModuloService>(); // si el servicio usa repositorio, recomendamos Scoped
services.AddTransient<MiModuloViewModel>();
```
Explicación: UseSqlServer (o UseSqlite) configura EF Core con la cadena de conexión. `Scoped` es el lifetime recomendado para repositorios/servicios que usan DbContext.


8) Migraciones EF Core (comandos)
- Añade paquete `Microsoft.EntityFrameworkCore.Tools` si no está instalado.
- Crear migración (desde la carpeta del .csproj):
  - `dotnet ef migrations add MiModulo_Initial -s GestLog.csproj -p GestLog.csproj`
- Aplicar migración:
  - `dotnet ef database update -s GestLog.csproj -p GestLog.csproj`

Explicación: las migraciones crean las tablas necesarias en la DB. `-s` y `-p` ayudan cuando la solución tiene varios proyectos.


9) View XAML (ejemplo WPF) - Views/MiModuloView.xaml
```xml
<Window x:Class="Modules.MiModulo.Views.MiModuloView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Mi Módulo" Height="400" Width="600">
    <StackPanel Margin="10">
        <TextBlock Text="{Binding Mensaje}" FontSize="16" Margin="0,0,0,10" />
        <StackPanel Orientation="Horizontal" Margin="0,0,0,10">
            <Button Content="Cargar" Command="{Binding CargarCommand}" Width="80" />
            <Button Content="Mostrar" Command="{Binding MostrarMensajeCommand}" Width="80" Margin="10,0,0,0" />
        </StackPanel>
        <ListBox ItemsSource="{Binding Elementos}" DisplayMemberPath="Nombre" Height="250" />
    </StackPanel>
</Window>
```
Explicación: la vista no contiene lógica, solo enlaces (bindings) a propiedades y comandos del ViewModel.


Registro de View / navegación (patrón simple):
- En Herramientas o desde donde se navegue, crea la instancia del ViewModel vía DI y asigna DataContext antes de mostrar la vista.

```csharp
using var scope = serviceProvider.CreateScope();
var vm = scope.ServiceProvider.GetRequiredService<MiModuloViewModel>();
var view = new Modules.MiModulo.Views.MiModuloView { DataContext = vm };
_mainWindow.NavigateToView(view, "Mi Módulo");
```

Explicación: se crea un scope para respetar el lifetime Scoped del DbContext/servicios.

---

Registro en DI (explicado simple)
- ¿Qué es DI? Es decirle a la app cómo crear objetos cuando los necesitas.
- ¿Dónde? `Startup.*.cs` o `Program.cs`.
- Ejemplo para copiar:
```csharp
// Services
services.AddTransient<IMiModuloService, MiModuloService(); // si es in-memory
// o
services.AddScoped<IMiModuloService, MiModuloService(); // si usa repositorios y DbContext

// Repositorio
services.AddScoped<IMiModuloRepository, MiModuloRepository>();

// ViewModel
services.AddTransient<MiModuloViewModel>();
```
Por qué elegir lifetimes:
- Transient: nueva instancia cada vez. Ideal para ViewModels.
- Scoped: una instancia por scope. Ideal para servicios que usan DbContext.
- Singleton: una sola instancia en toda la app. Evitar si tienes datos por usuario o DbContext.


---

Integración con Herramientas (añadir la card)
1) Crear permiso: define un identificador consistente, ej. `Herramientas.AccederMiModulo`.
2) Añadir comprobación en `HerramientasViewModel`:
```csharp
[ObservableProperty]
private bool canAccessMiModulo;

private void RecalcularPermisos()
{
    CanAccessMiModulo = _currentUser.HasPermission("Herramientas.AccederMiModulo");
}
```
3) En `HerramientasView.xaml` añade un botón/card (copia y modifica uno existente):
```xml
<Button Content="Mi Módulo"
        Click="BtnMiModulo_Click"
        Visibility="{Binding CanAccessMiModulo, Converter={StaticResource BooleanToVisibilityConverter}}" />
```
4) Implementar `BtnMiModulo_Click` siguiendo el patrón del proyecto (ejemplo):
```csharp
private void BtnMiModulo_Click(object sender, RoutedEventArgs e)
{
    var serviceProvider = LoggingService.GetServiceProvider(); // o la forma que use la app
    using var scope = serviceProvider.CreateScope();
    var miVm = scope.ServiceProvider.GetRequiredService<MiModuloViewModel>();
    var miView = new Modules.MiModulo.Views.MiModuloView { DataContext = miVm };
    _mainWindow.NavigateToView(miView, "Mi Módulo");
}
```
Explicación: se crea un scope para respetar `Scoped` y se resuelve el ViewModel para inyectar dependencias.


---

Permisos: cómo crearlos y comprobarlos
- Define permisos como cadenas constantes (ej. `public const string AccederMiModulo = "Herramientas.AccederMiModulo";`).
- Añádelos al sistema de roles/permisos que usa GestLog (buscar archivo donde se registran permisos globales en el proyecto).
- En la UI, comprobar permiso con el usuario actual antes de mostrar la card o permitir acciones.

---

Transacciones y manejo de errores (DB)
- Transacciones con EF Core (ejemplo):
```csharp
using var transaction = await _db.Database.BeginTransactionAsync();
try
{
    // varias operaciones
    await _repo.GuardarAsync(entity);
    await _db.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch (Exception ex)
{
    await transaction.RollbackAsync();
    // log y rethrow o manejar
    _logger.LogError(ex, "Error al guardar MiModulo");
    throw;
}
```
Explicación: agrupa varias operaciones para que todas se confirmen o ninguna.

Manejo de errores simple:
- Captura excepciones, registra con ILogger y muestra mensaje de usuario amigable.
- No exponer mensajes técnicos en UI.

---

## Git y GitHub (sencillo y rápido)

Objetivo: pasos mínimos y seguros para que un novato pueda trabajar en una rama y crear un Pull Request en GitHub.

1) Preparar (solo la primera vez)
```powershell
git --version
git config --global user.name "Tu Nombre"
git config --global user.email "tu.email@empresa.com"
```
2) Clonar el repositorio (si no lo tienes)
```powershell
git clone https://github.com/tu-organizacion/GestLog.git
cd GestLog
```
3) Crear y usar una rama de trabajo
```powershell
# Asegúrate de partir de la rama principal actualizada
git checkout main
git pull origin main
# Crea y cámbiate a tu rama de trabajo
git checkout -b feature/mi-modulo
```
4) Hacer cambios y guardar (commits)
```powershell
git status            # ver archivos cambiados
git add .             # añadir todos los cambios preparados
git commit -m "feat(mi-modulo): descripción corta"
```
Consejo: haz commits pequeños y con mensajes claros.

5) Traer cambios recientes y subir tu rama (usar merge)
```powershell
# Trae los cambios remotos
git fetch origin
# Mueve a tu rama de trabajo
git checkout feature/mi-modulo
# Fusiona (merge) la rama principal actualizada en tu rama
git merge origin/main
# Si todo ok, sube tu rama
git push -u origin feature/mi-modulo
```
Nota: si el equipo usa `develop` en lugar de `main`, sustituye `main` por `develop` en los comandos.

6) Abrir el Pull Request en GitHub (muy simple)
- Ve a https://github.com/tu-organizacion/GestLog y pulsa "Compare & pull request" sobre tu rama.
- Título: breve y claro. Ej.: `feat(mi-modulo): añadir esqueleto del módulo`.
- Descripción: ¿qué hace? ¿cómo probar? (ver plantilla mínima abajo).
- Selecciona revisores y crea el PR.

Opción: usar Visual Studio Code (interfaz gráfica)

Si prefieres una interfaz visual, VS Code incluye control de versiones y se integra con GitHub. Pasos básicos:

1. Abrir el proyecto en VS Code: `File -> Open Folder` y selecciona la carpeta del repositorio.
2. Iniciar sesión en GitHub (solo la primera vez):
   - Haz clic en el icono de la cuenta (en la esquina inferior izquierda) o abre la Command Palette (Ctrl+Shift+P) y ejecuta `GitHub: Sign in`.
   - Sigue el flujo para autorizar VS Code con tu cuenta de GitHub.
3. Crear rama desde la barra de estado:
   - En la esquina inferior izquierda verás la rama actual (ej. `main`). Haz clic y selecciona `Create new branch...`.
   - Escribe `feature/mi-modulo` y pulsa Enter. VS Code cambia automáticamente a la nueva rama.
4. Hacer cambios y preparar commit (Source Control panel):
   - Abre el panel Source Control (icono de rama/instrumento o Ctrl+Shift+G).
   - Verás los archivos modificados. Usa el botón "+" al lado de cada archivo para stagearlos, o el botón "Stage All".
   - Escribe el mensaje en la caja de commit arriba y pulsa el icono de check para commitear.
5. Publicar (push) la rama:
   - Si la rama no existe en remoto, aparecerá un botón "Publish Branch" en la barra superior del panel Source Control o en la barra de estado. Haz clic para subirla.
6. Crear Pull Request desde VS Code:
   - Después de publicar, VS Code mostrará un enlace para "Create Pull Request"; o usa la Command Palette: `GitHub: Create Pull Request`.
   - Rellena título y descripción y selecciona la rama base (`main` o `develop`). Puedes marcar el PR como Draft si aún no está listo.
7. Revisar estado y resolver conflictos:
   - Si Git muestra conflictos, VS Code proporciona un editor con botones para aceptar cambios entrantes/origen o combinarlos. Después de resolver, `Stage` y `Commit` los archivos resueltos y `Push`.

Ventajas de usar VS Code:
- Visual y más fácil para principiantes.
- Ver diffs integrados y resolver conflictos con botones.
- Crear PR sin salir del editor.

---

Plantilla mínima para la descripción del PR (copiar/pegar):
```
Resumen: Añade el módulo Mi Módulo (vista y ViewModel) con servicio in-memory.
Cómo probar:
1. git checkout feature/mi-modulo
2. Compilar y ejecutar la app
3. Abrir Herramientas -> Mi Módulo
Checklist:
- [ ] Código compila
- [ ] Cambios en Modules/MiModulo
- [ ] README y Documentación de usuario añadidos
```

Resolución rápida de conflictos (flujo de merge)
- Si durante `git merge origin/main` hay conflictos, Git marcará los archivos en conflicto.
- Abre el archivo y busca las marcas `<<<<<<<`, `=======`, `>>>>>>>`.
- Elige qué código conservar, edita y guarda.
- Marca el archivo como resuelto y crea el commit de merge:
```powershell
git add path\al\archivo
git commit -m "Resolver conflicto al merge con origin/main"
```
- Luego sube tu rama:
```powershell
git push
```
Si no sabes resolver un conflicto, pide ayuda al revisor.

Después de merge en GitHub
```powershell
git checkout main
git pull origin main
# Borrar la rama remota (opcional)
git push origin --delete feature/mi-modulo
# Borrar la rama local (opcional)
git branch -d feature/mi-modulo
```

Reglas importantes (muy breves)
- No subir secretos ni archivos binarios.
- Evita tocar archivos globales si no es necesario; si lo haces, explica por qué.
- Si no estás seguro, crea un PR en modo "Draft" para recibir feedback.

---

Checklist final antes de PR
- [ ] Carpetas y archivos del módulo creados en `Modules/MiModulo`.
- [ ] Implementación mínima con datos en memoria (si procede).
- [ ] Si hay persistencia: entidades, DbContext y migraciones creadas.
- [ ] Servicios y ViewModels registrados en DI.
- [ ] Card añadida en `HerramientasView` y flag de permiso en `HerramientasViewModel`.
- [ ] Permisos registrados en el sistema de roles.
- [ ] Documentación de usuario en `DocumentacionModulos/MiModulo-Usuario.md`.
- [ ] README del módulo con dependencias y instrucciones de migraciones.

---