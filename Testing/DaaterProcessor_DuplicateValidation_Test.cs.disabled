using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Threading;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using GestLog.Modules.DaaterProccesor.Services;
using GestLog.Services.Core.Logging;

namespace GestLog.Testing
{
    /// <summary>
    /// Tests para validar la funcionalidad de detección de duplicados en DaaterProcessor
    /// </summary>
    [TestClass]
    public class DaaterProcessor_DuplicateValidation_Test
    {
        private DataConsolidationService _service;
        private IGestLogLogger _logger;
        private string _testDataPath;

        [TestInitialize]
        public void Setup()
        {
            _logger = LoggingService.GetLogger();
            _service = new DataConsolidationService(_logger);
            _testDataPath = Path.Combine(Path.GetTempPath(), "GestLog_Test_" + Guid.NewGuid().ToString("N")[..8]);
            Directory.CreateDirectory(_testDataPath);
        }

        [TestCleanup]
        public void Cleanup()
        {
            if (Directory.Exists(_testDataPath))
            {
                Directory.Delete(_testDataPath, true);
            }
        }

        [TestMethod]
        public void DuplicateDetection_ShouldOmitDuplicateRecords()
        {
            // Arrange
            var testExcelFile = CreateTestExcelWithDuplicates();
            var paises = new Dictionary<string, string> { { "CO", "Colombia" } };
            var partidas = new Dictionary<long, string[]> 
            { 
                { 123456, new[] { "Test Product", "Test", "Test", "Test", "Test", "Test" } } 
            };
            var proveedores = new Dictionary<string, string> { { "test@provider.com", "Test Provider" } };

            // Act
            var result = _service.ConsolidarDatos(_testDataPath, paises, partidas, proveedores, null, CancellationToken.None);

            // Assert
            Assert.IsNotNull(result, "El resultado no debe ser nulo");
            
            // Deberíamos tener solo 2 registros únicos, no 3 (uno duplicado debe ser omitido)
            Assert.AreEqual(2, result.Rows.Count, "Debe haber exactamente 2 registros únicos después de omitir duplicados");
            
            // Verificar que los registros únicos están presentes
            var partidasEncontradas = new HashSet<long>();
            var declaracionesEncontradas = new HashSet<long>();
            
            foreach (DataRow row in result.Rows)
            {
                var partida = Convert.ToInt64(row["PARTIDA ARANCELARIA"]);
                var declaracion = Convert.ToInt64(row["Número Declaración"]);
                
                partidasEncontradas.Add(partida);
                declaracionesEncontradas.Add(declaracion);
            }
            
            Assert.IsTrue(partidasEncontradas.Contains(123456), "Debe contener la partida 123456");
            Assert.IsTrue(partidasEncontradas.Contains(654321), "Debe contener la partida 654321");
            Assert.IsTrue(declaracionesEncontradas.Contains(111111), "Debe contener la declaración 111111");
            Assert.IsTrue(declaracionesEncontradas.Contains(222222), "Debe contener la declaración 222222");
        }

        [TestMethod]
        public void DuplicateDetection_ShouldLogWarningsForDuplicates()
        {
            // Arrange
            var testExcelFile = CreateTestExcelWithDuplicates();
            var paises = new Dictionary<string, string> { { "CO", "Colombia" } };
            var partidas = new Dictionary<long, string[]> 
            { 
                { 123456, new[] { "Test Product", "Test", "Test", "Test", "Test", "Test" } } 
            };
            var proveedores = new Dictionary<string, string> { { "test@provider.com", "Test Provider" } };

            // Act & Assert
            // Este test verifica que la funcionalidad no lance excepciones
            // El logging de warnings se puede verificar mediante inspección manual de logs
            Assert.DoesNotThrow(() =>
            {
                var result = _service.ConsolidarDatos(_testDataPath, paises, partidas, proveedores, null, CancellationToken.None);
            });
        }

        private string CreateTestExcelWithDuplicates()
        {
            var filePath = Path.Combine(_testDataPath, "test_duplicates.xlsx");
            
            // Este método simularía la creación de un archivo Excel con datos duplicados
            // Para un test real, se usaría ClosedXML para crear el archivo
            // Por ahora, documentamos la estructura esperada:
            /*
             * Estructura del archivo Excel de prueba:
             * Fila 1 (Header): FECHA DECLARACIÓN, NÚMERO DECLARACIÓN, IMPORTADOR, IMPORTADOR, 
             *                  EXPORTADOR (PROVEEDOR), DIRECCIÓN EXPORTADOR (PROVEEDOR), 
             *                  DATO DE CONTACTO EXPORTADOR, PAÍS EXPORTADOR, PAÍS DE ORIGEN, 
             *                  PARTIDA ARANCELARIA, , NÚMERO DE BULTOS, PESO NETO, 
             *                  VALOR FOB (USD), DESCRIPCIÓN MERCANCÍA
             * 
             * Fila 2: 2025-01-01, 111111, 123456789, Importador Test, Proveedor Test, Calle 123, test@provider.com, CO, CO, 123456, , 10, 1000, 5000, Producto Test
             * Fila 3: 2025-01-02, 222222, 987654321, Importador Test 2, Proveedor Test 2, Calle 456, test2@provider.com, CO, CO, 654321, , 20, 2000, 10000, Producto Test 2
             * Fila 4: 2025-01-03, 111111, 123456789, Importador Test, Proveedor Test, Calle 123, test@provider.com, CO, CO, 123456, , 10, 1000, 5000, Producto Test (DUPLICADO)
             */
            
            // TODO: Implementar creación real del archivo Excel usando ClosedXML
            // Por ahora, retornamos el path donde debería estar el archivo
            
            return filePath;
        }
    }

    /// <summary>
    /// Extensión para hacer Assert.DoesNotThrow compatible con MSTest
    /// </summary>
    public static class AssertExtensions
    {
        public static void DoesNotThrow(Action action)
        {
            try
            {
                action();
            }
            catch (Exception ex)
            {
                Assert.Fail($"Se esperaba que no se lanzara ninguna excepción, pero se lanzó: {ex.GetType().Name}: {ex.Message}");
            }
        }
    }
}
